<?xml version="1.0" encoding="utf-8"?>
<PTRepeater xmlns="com.broceliand.ui.list.*"
            xmlns:mx="http://www.adobe.com/2006/mxml"
            implements="com.broceliand.ui.list.INoteList"
            xmlns:note="com.broceliand.ui.pearlWindow.ui.note.*"
            updateComplete="FixedSizeScrollThumb.replaceScrollThumb(ScrollBar(verticalScrollBar))"
            creationComplete="fixMouseWheel()"
            verticalLineScrollSize="30">
   
   <mx:VBox backgroundColor="{ColorPalette.getInstance().backgroundColor}"
            backgroundAlpha="0"
            verticalGap="0"
            width="100%">
      <mx:Repeater id="noteRepeater"
                   width="{width}"
                   recycleChildren="true"
                   startingIndex="0">
         <note:PWNoteItem item="{noteRepeater.currentItem}" notePanel="{notePanel}" />
      </mx:Repeater>
   </mx:VBox>
   
   <mx:Metadata>
      [Event(name="onDeleteNote", type="flash.events.Event")]
      [Event(name="onReplyToNote", type="flash.events.Event")]
   </mx:Metadata>
   <mx:Script>
      <![CDATA[
         import com.broceliand.ApplicationManager;
         import com.broceliand.pearlTree.model.BroComment;
         import com.broceliand.pearlTree.model.BroPTNode;
         import com.broceliand.ui.model.NoteModel;
         import com.broceliand.ui.pearlWindow.ui.note.PWNoteItem;
         import com.broceliand.ui.pearlWindow.ui.note.PWNotePanel;
         import com.broceliand.ui.util.ColorPalette;
         import com.broceliand.util.flexWorkaround.FirefoxMacMouseWheelFix;
         
         import mx.collections.ArrayCollection;
         import mx.controls.scrollClasses.ScrollBar;
         import mx.controls.scrollClasses.ScrollThumb;
         import mx.core.IRepeater;
         import mx.events.FlexEvent;
         
         protected var _notes:ArrayCollection;
         protected var _deletable:Boolean;
         protected var _notifyNewNotes:Boolean;
         protected var _node:BroPTNode;
         private var nodeChanged:Boolean;
         private var notesChanged:Boolean;
         private var refreshDataProvider:Boolean;
         private var _notePanel:PWNotePanel;
         
         use namespace mx_internal;
         
         public static const DELETE_EVENT:String = "onDeleteNote";
         public static const REPLY_EVENT:String = "onReplyToNote";
         
         public function set notePanel(value:PWNotePanel):void {
            _notePanel = value;
         }
         
         [Bindable]
         public function get notePanel():PWNotePanel {
            return _notePanel;
         }
         
         override public function set dataProvider(value:Object):void {
            if(_notes != value) {
               _notes = value as ArrayCollection;
               refreshDataProvider = true;
            }
            invalidateProperties();
         }
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         override protected function commitProperties():void{
            super.commitProperties();
            
            
            
            if(nodeChanged && !notesChanged && _notes) {
               purgeList();
               super.dataProvider = _notes;
            }
            if(refreshDataProvider) {
               refreshDataProvider = false;
               super.dataProvider = _notes;
            }
            
            nodeChanged = false;
            notesChanged = false;
         }
         
         public function set node(value:BroPTNode):void {
            if(value != _node) {
               _node = value;
               nodeChanged = true;
               invalidateProperties();
            }
         }
         public function get node():BroPTNode {
            return _node;
         }
         
         public function isLocalNote(note:BroComment):Boolean {
            return ApplicationManager.getInstance().visualModel.noteModel.isLocalNote(note, _node);
         }
         
         public function set deletable(value:Boolean):void{
            _deletable = value;
         }
         public function get deletable():Boolean{
            return _deletable;
         }
         
         public function get notifyNewNotes():Boolean {
            return _notifyNewNotes;
         }
         public function set notifyNewNotes(value:Boolean):void {
            if(_notifyNewNotes != value) {
               _notifyNewNotes = value;
               for each(var item:Object in noteRepeater.createdComponents) {
                  if(item is PWNoteItem) {
                     PWNoteItem(item).invalidateProperties();
                  }
               }
            }
         }
         
         public function deleteNote(note:BroComment):void {
            dispatchEvent(new NoteListEvent(note, DELETE_EVENT));
         }
         
         public function replyToNote(note:BroComment):void {
            dispatchEvent(new NoteListEvent(note, REPLY_EVENT));
         }
         
         override protected function get innerRepeater():mx.core.Repeater {
            return noteRepeater as mx.core.Repeater;
         }
         
         public function getNotePosition(note:BroComment):uint {
            return ArrayCollection(noteRepeater.dataProvider).getItemIndex(note) + 1;
         }
         public function isLastNote(note:BroComment):Boolean {
            var notePosition:Number = getNotePosition(note);
            var numNotes:Number = ArrayCollection(noteRepeater.dataProvider).length;
            return (notePosition == numNotes);
         }
         
         public function autoScroll(noteItem:PWNoteItem):void {
            
            var focusItem : DisplayObject = noteItem;
            
            if(verticalScrollBar && focusItem) {
               if( focusItem == this || !contains(focusItem) ) {
                  return;
               }
               
               var focusTopEdge : int = focusItem.y;
               var thisItem : DisplayObjectContainer = focusItem.parent;
               while(thisItem != this) {
                  focusTopEdge += thisItem.y;
                  thisItem = thisItem.parent;
               }
               var focusBottomEdge : int = focusTopEdge + focusItem.height;
               var scrollbarRange : int = verticalScrollBar.maxScrollPosition;
               
               var visibleWindowHeight : int = height;
               
               var lastVisibleY : int = visibleWindowHeight + verticalScrollPosition;
               if(horizontalScrollBar) {
                  lastVisibleY -= horizontalScrollBar.height;
               }
               else if( focusTopEdge < verticalScrollPosition ) {
                  verticalScrollPosition = focusTopEdge;
               }
               else if( focusBottomEdge-lastVisibleY > 0 ) {
                  var newPos : int = Math.min(scrollbarRange, verticalScrollPosition + (focusBottomEdge-lastVisibleY));
                  verticalScrollPosition = newPos;
               }
            }
         }
         
         public function loadNextPage():void {
            if (notePanel.model.noteType == NoteModel.TYPE_NOTE)
               ApplicationManager.getInstance().visualModel.noteModel.loadNextPage(node);
            else 
               ApplicationManager.getInstance().visualModel.teamDiscussionModel.loadNextPage(node);
         }
         
         public function fixMouseWheel():void 
         {
            FirefoxMacMouseWheelFix.fixFirefoxMacWheelOnScroll(this);
         }
         
      ]]>
   </mx:Script>
</PTRepeater>
